syntax = "proto3";

package appscode.kubernetes.v1beta1;

option go_package = "v1beta1";

option java_multiple_files = true;
option java_outer_classname = "ClientProto";
option java_package = "com.appscode.api.kubernetes.v1beta1";

import "google/api/annotations.proto";
import "appscode/api/annotations.proto";
import "appscode/api/dtypes/types.proto";

service Clients {
  rpc List(ListResourceRequest) returns (ListResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/{type}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DescribeResourceRequest) returns (DescribeResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/{type}/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(CreateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/{type}/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DeleteResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/{type}/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Update(UpdateResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/{type}/{name}/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Copy(CopyResourceRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      put : "/_appscode/api/kubernetes/v1beta1/actions/copy/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  // Followings are type specific actions api, that can be applied upon fixed resources.
  // TODO: (@sadlil) Consider seperating them.
  rpc EditConfigMap(ConfigMapEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/namespaces/{namespace}/configmaps/{name}/actions/edit/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc EditSecret(SecretEditRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post : "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/namespaces/{namespace}/secrets/{name}/actions/edit/json"
      body : "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolume(PersistentVolumeRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/persistentvolumes/{name}/actions/register/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolume(PersistentVolumeUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/persistentvolumes/{name}/actions/unregister/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc RegisterPersistentVolumeClaim(PersistentVolumeClaimRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/persistentvolumeclaims/{name}/actions/register/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc UnregisterPersistentVolumeClaim(PersistentVolumeClaimUnRegisterRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/persistentvolumeclaims/{name}/actions/unregister/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc ReverseIndex(ReverseIndexResourceRequest) returns (ListResourceResponse){
    option (google.api.http) = {
      get : "/_appscode/api/kubernetes/v1beta1/clusters/{cluster}/{type}/{name}/{targetType}/reverseindex/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

service Disks {
  rpc List(DiskListRequest) returns (DiskListResponse) {
    option (google.api.http) = {
      get: "/_appscode/api/cloud/v1beta1/disks/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Describe(DiskDescribeRequest) returns (DiskDescribeResponse) {
    option (google.api.http) = {
      get: "/_appscode/api/cloud/v1beta1/disks/{name}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Create(DiskCreateRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      post: "/_appscode/api/cloud/v1beta1/disks/json"
      body: "*"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }

  rpc Delete(DiskDeleteRequest) returns (dtypes.VoidResponse) {
    option (google.api.http) = {
      delete: "/_appscode/api/cloud/v1beta1/disks/{uid}/json"
    };
    option (appscode.api.cors) = {
      enable: true
    };
  }
}

message ListResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string api_version = 4;
  bool include_metrics = 5;
  // map type is not supported by grpc-gateway as query params.
  // https://github.com/grpc-ecosystem/grpc-gateway/blob/master/runtime/query.go#L57
  // https://github.com/grpc-ecosystem/grpc-gateway/issues/316
  // map<string, string> label_selector = 6;
  // example label_selector=environment=production,tier=frontend
  string selector = 6;
}

message ReverseIndexResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 3;
  string namespace = 4;
  string api_version = 5;
  string targetType = 7;
}

message ListResourceResponse {
  KubeResourceList resources = 1;
  repeated string available_versions = 2;
  string preferred_version = 3;
}

message DescribeResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  string raw = 5;
  bool include_metrics = 6;
  string api_version = 7;
}

message DescribeResourceResponse {
  KubeResource resource = 1;
}

message UpdateResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  Raw raw = 5;
  string api_version = 6;
}

message ConfigMapEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string> add = 4;
  map<string, string> update = 5;
  repeated string deleted = 6;
}

message SecretEditRequest {
  string cluster = 1;
  string namespace = 2;
  string name = 3;
  map<string, string>  add = 4;
  map<string, string>  update = 5;
  repeated string deleted = 6;
}

message CopyResourceRequest {
  KubeObject source = 1;
  KubeObject destination = 2;
  string api_version = 3;
}

message CreateResourceRequest {
  string cluster = 1;
  string type = 2;
  string name = 4;
  Raw raw = 5;
  string api_version = 6;
}

message DeleteResourceRequest {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
  string api_version = 5;
}

message KubeResourceList {
  string api_version = 1;
  string kind = 2;
  oneof  resource {
    ConfigMaps config_maps = 3;
    DaemonSets daemon_sets = 4;
    Deployments deployments = 5;
    Jobs jobs = 6;
    Namespaces namespaces = 7;
    Nodes nodes = 8;
    StatefulSets stateful_sets = 9;
    Pods pods = 10;
    ReplicaSets replica_sets = 11;
    Services services = 12;
    Secrets secrets = 13;
    ReplicationControllers replication_controllers = 14;
    StorageClasses storage_classes = 15;
    PersistentVolumes persistent_volumes = 16;
    PersistentVolumeClaims persistent_volume_claims = 17;
    Roles roles = 18;
    ClusterRoles cluster_roles = 19;
    RoleBindings role_bindings = 20;
    ClusterRoleBindings cluster_role_bindings = 21;
    Certificates certificates = 22;
    CronJobs cron_jobs = 23;
    Restics restics = 24;
    Postgreses postgreses = 25;
    // `elasticsearchs` is spelled incorrectly. This is intentional, since Kubernetes itself uses has a pluralization bug.
    Elasticsearches elasticsearchs = 26;
    DormantDatabases dormant_databases = 27;
    Snapshots snapshots = 28;
    Events events = 29;
    Ingresses ingresses = 30;
    Prometheuses prometheuses = 31;
    ServiceMonitors service_monitors = 32;
    ClusterAlerts cluster_alerts = 33;
    NodeAlerts node_alerts = 34;
    PodAlerts pod_alerts = 35;
  }

  message Events {
    repeated Event items = 1;
  }

  message ConfigMaps {
    repeated ConfigMap items = 1;
  }

  message DaemonSets {
    repeated DaemonSet items = 1;
  }

  message Deployments {
    repeated Deployment items = 1;
  }

  message Jobs {
    repeated Job items = 1;
  }

  message Namespaces {
    repeated Namespace items = 1;
  }

  message Nodes {
    repeated Node items = 1;
  }

  message StatefulSets {
    repeated StatefulSet items = 1;
  }

  message Pods {
    repeated Pod items = 1;
  }

  message ReplicaSets {
    repeated ReplicaSet items = 1;
  }

  message Services {
    repeated Service items = 1;
  }

  message Secrets {
    repeated Secret items = 1;
  }

  message ReplicationControllers {
    repeated ReplicationController items = 1;
  }

  message StorageClasses {
    repeated StorageClass items = 1;
  }

  message PersistentVolumes {
    repeated PersistentVolume items = 1;
  }

  message PersistentVolumeClaims {
    repeated PersistentVolumeClaim items = 1;
  }

  message ClusterAlerts {
    repeated ClusterAlert items = 1;
  }

  message NodeAlerts {
    repeated NodeAlert items = 1;
  }

  message PodAlerts {
    repeated PodAlert items = 1;
  }

  message Roles {
    repeated Role items = 1;
  }

  message ClusterRoles {
    repeated ClusterRole items = 1;
  }

  message RoleBindings {
    repeated RoleBinding items = 1;
  }

  message ClusterRoleBindings {
    repeated ClusterRoleBinding items = 1;
  }

  message Certificates {
    repeated Certificate items = 1;
  }

  message CronJobs {
    repeated CronJob items = 1;
  }

  message Postgreses {
    repeated Postgres items = 1;
  }

  message Elasticsearches {
    repeated Elasticsearch items = 1;
  }

  message DormantDatabases {
    repeated DormantDatabase items = 1;
  }

  message Snapshots {
    repeated Snapshot items = 2;
  }

  message Restics {
    repeated Restic items = 1;
  }

  message Ingresses {
    repeated Ingress items = 1;
  }

  message Prometheuses {
    repeated Prometheus items = 1;
  }

  message ServiceMonitors {
    repeated ServiceMonitor items = 1;
  }
}

// TODO: (@sadlil): when kubernetes moves to protobuf completely import fileds from there.
message KubeResource {
  string api_version = 1;
  string kind = 2;
  Raw raw = 3;
  repeated Event events = 4;
  oneof  resource {
    ConfigMap config_map = 5;
    DaemonSet daemon_set = 6;
    Deployment deployment = 7;
    Job job = 8;
    Namespace namespace = 9;
    Node node = 10;
    StatefulSet stateful_set = 11;
    Pod pod = 12;
    ReplicaSet replica_set = 13;
    Service service = 14;
    Secret secret = 15;
    ReplicationController replication_controller = 16;
    StorageClass storage_class = 17;
    PersistentVolume persistent_volume = 18;
    PersistentVolumeClaim persistent_volume_claim = 19;
    Role role = 20;
    ClusterRole cluster_role = 21;
    RoleBinding role_binding = 22;
    ClusterRoleBinding cluster_role_binding = 23;
    Certificate certificate = 24;
    CronJob cron_job = 25;
    Restic restic = 26;
    Postgres postgres = 27;
    Elasticsearch elasticsearch = 28;
    DormantDatabase dormant_database = 29;
    Snapshot snapshot = 30;
    Ingress ingress = 31;
    Prometheus prometheus = 32;
    ServiceMonitor service_monitors = 33;
    ClusterAlert cluster_alert = 34;
    NodeAlert node_alert = 35;
    PodAlert pod_alert = 36;
  }
}

message Meta {
  string name = 1;
  string namespace = 2;
  string self_link = 3;
  string resource_version = 4;
  int64 creation_timestamp = 5;
  int64 generation = 6;
  map<string, string> labels = 7;
  map<string, string> annotations = 8;
  string uid = 9;
}

message KubeObject {
  string cluster = 1;
  string type = 2;
  string namespace = 3;
  string name = 4;
}

message IcingaState {
  int32 OK = 1;
  int32 Warning = 2;
  int32 Critical = 3;
  int32 Unknown = 4;
}

message PodSpec {
  repeated Volume volumes = 1;
  repeated Container containers = 2;
  map<string, string> node_selector = 3;
  string service_account_name = 4;
  string node_name = 5;
  repeated string image_pull_secrets = 6;

  message Container {
    string name  = 1;
    string image = 2;
    repeated string commands = 3;
    repeated VolumeMount volume_mounts = 4;
    repeated string args = 5;
    string working_dir = 6;
    repeated EnvVar env = 7;
  }
}

message Volume {
  string name = 1;
  VolumeSource volumeSource = 2;
}

message VolumeMount {
  string name = 1;
  bool read_only = 2;
  string mount_path = 3;
}

message Raw {
  string format = 1;
  string data = 2;
}

message ConfigMap {
  Meta meta = 1;
  map<string, string> data = 2;
}

message Job {
  Meta meta = 1;
  string app = 2;
  JobSpec spec = 3;
  Status status = 4;

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    int32 active = 3;
    int32 succeeded = 4;
    int32 failed = 5;
    repeated ResourceCondition conditions = 6;
  }
}

message JobSpec {
  int32 parallelism = 1;
  int32 completions = 2;
  PodSpec template = 3;
  int64 active_deadline_seconds = 4;

}

message Namespace {
  Meta meta = 1;
  Status status = 2;
  NamespaceSpec spec = 3;

  message NamespaceSpec {
    repeated string finalizers = 1;
  }

  message Status {
    string phase = 1;
  }
}

message Node {
  Meta meta = 1;
  Spec spec = 2;
  bool is_master = 3;
  NodeStatus status = 4;
  Metrics metrics = 5;

  message Spec {
    string external_id = 1;
    string provider_id = 2;
    bool unschedulable = 3;
    string podCIDR = 4;
  }

  message NodeStatus {
    Capacity capacity = 1;
    string phase = 2;
    NodeSystemInfo node_info = 3;
    Capacity allocatable = 4;
    repeated ResourceCondition conditions = 5;
    repeated NodeAddress address = 6;
    repeated ContainerImage images = 7;
    repeated string volumes_in_use = 8;
    repeated AttachedVolume volumes_attached = 9;

    message Capacity {
      int64 cpu = 1;
      int64 memory = 2;
      int64 pods = 3;
      string storage = 4;
    }

    message NodeSystemInfo {
      string machineID = 6;
      string systemUUID = 7;
      string bootID = 8;
      string kernel_version = 1;
      string os_image = 2;
      string container_runtime_version = 3;
      string kubelet_version = 4;
      string kube_proxy_version = 5;
      string operating_system = 9;
      string architecture = 10;
    }

    message NodeAddress {
      string type = 1;
      string address = 2;
    }

    message ContainerImage {
      repeated string names = 1;
      int64 size_bytes = 2;
    }

    message AttachedVolume {
      string name = 1;
      string device_path = 2;
    }
  }
}

message Pod {
  Meta meta = 1;
  string app = 2;
  PodSpec spec = 3;
  PodStatus status = 4;
  Metrics metrics = 5;

  message PodStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
    string hostIP = 4;
    string podIP = 5;
    repeated ResourceCondition conditions = 6;
    int64 start_time = 7;
    repeated Service service_info = 8;
  }
}

message PersistentVolume {
  Meta meta = 1;
  PersistentVolumeSpec spec = 2;
  PersistentVolumeStatus status = 3;

  message PersistentVolumeSpec {
    map <string, string> capacity = 1;
    repeated string access_modes = 2;
    string persistent_volume_reclaim_policy = 3;
    ObjectReference claim_ref = 4;
    VolumeSource persistent_volume_source = 5;
  }

  message PersistentVolumeStatus {
    string phase = 1;
    string message = 2;
    string reason = 3;
  }
}

message PersistentVolumeClaim {
  Meta meta = 1;
  PersistentVolumeClaimSpec spec = 2;
  PersistentVolumeClaimStatus status = 3;

  message PersistentVolumeClaimStatus {
    string phase = 1;
    repeated string access_modes = 2;
    map <string, string> capacity = 3;
  }
}

message PersistentVolumeClaimSpec {
  string storage_class_name = 1;
  repeated string access_modes = 2;
  ResourceRequirements resources = 3;
  string volume_name = 4;

  message ResourceRequirements {
    map<string, string> limits = 1;
    map<string, string> requests = 2;
  }
}

message ObjectReference {
  string kind = 1;
  string namespace = 2;
  string name = 3;
  string uid = 4;
  string api_version = 5;
  string resource_version = 6;
}

message Service {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    string type = 1;
    repeated Port ports = 2;
    string selector = 3;
    string clusterIP = 4;
    repeated string externalIPs = 5;
    string loadbalancerIP = 6;
    string external_name = 7;
    string session_affinity = 8;
    repeated string load_balancer_source_ranges = 9;

    message Port {
      string name = 1;
      string protocol = 2;
      int32 port = 3;
      string target_port = 4;
      int32 node_port = 5;
    }
  }

  message Status {
    repeated LoadBalancerIngress loadbalancer_ingresses = 1;

    message LoadBalancerIngress {
      string host_name = 1;
      string IP = 2;
    }
  }
}

message Secret {
  Meta meta = 1;
  map<string, string> data = 2;
  string type = 3;
}

message ReplicationController {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message ReplicaSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message DaemonSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    string selector = 1;
    PodSpec pod_template = 2;
  }

  message Status {
    int32 current_number_scheduled = 1;
    int32 number_misscheduled = 2;
    int32 desired_number_scheduled = 3;
  }
}

message Deployment {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  DeploymentStatus status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
    int32 min_ready_seconds = 4;
    int32 revision_history_limit = 5;
    bool paused = 6;
    RollbackConfig rollback_to = 7;
    int32 progress_deadline_seconds = 8;
    DeploymentStrategy strategy = 9;

    message DeploymentStrategy {
      string type = 1;
      RollingUpdateDeployment rolling_update = 2;
    }

    message RollingUpdateDeployment {
      string max_unavailable = 1;
      string max_surge = 2;
    }

    message RollbackConfig {
      int64 revision = 1;
    }
  }

  message DeploymentStatus {
    int64 observed_generation = 1;
    int32 replicas = 2;
    int32 updated_replicas = 3;
    int32 available_replicas = 4;
    int32 unavailable_replicas = 5;
    repeated ResourceCondition conditions = 6;
  }
}

message StatefulSet {
  Meta meta = 1;
  string app = 2;
  Spec spec = 3;
  Status status = 4;

  message Spec {
    int32 desired_replicas = 1;
    string selector = 2;
    PodSpec pod_template = 3;
    string service_name = 4;
  }

  message Status {
    int32 current_replicas = 1;
    int64 observed_generation = 2;
  }
}

message StorageClass {
  Meta meta = 1;
  string provisioner = 2;
  map<string, string> parameters = 3;
}

message Event {
  Meta meta = 1;
  string reason = 2;
  string message = 3;
  EventSource source = 4;
  int64 first_timestamp = 5;
  int64 last_timestamp = 6;
  int32 count = 7;
  string type = 8;
}

message EventSource {
  string component = 1;
  string host = 2;
}

message Metrics {
  repeated DataPoint cpu_usage = 1;
  repeated DataPoint memory_usage = 2;

  message DataPoint {
    int64 timestamp = 1;
    int64 value     = 2;
  }
}

message PersistentVolumeRegisterRequest {
  string cluster = 1;
  string name = 2;
  string identifier = 3;
  string plugin = 4;
  int64 size_gb = 5;
  string endpoint = 6;
}

message PersistentVolumeUnRegisterRequest {
  string cluster = 1;
  string name = 2;
}

message PersistentVolumeClaimRegisterRequest {
  string cluster = 1;
  string name = 2;
  int64 size_gb = 3;
  string namespace = 4;
}

message PersistentVolumeClaimUnRegisterRequest {
  string cluster = 1;
  string name = 2;
  string namespace = 3;
}

message ClusterAlert {
  Meta meta = 1;
  ClusterAlertSpec spec = 2;

  message ClusterAlertSpec {
    // Icinga CheckCommand name
    // Values are in
    //    any_http
    //    component_status
    //    json_path
    //    node_exists
    //    pod_exists
    //    kube_event
    //    certificate_expiry
    //    hello_icinga
    //    dig
    //    dns
    //    dummy
    //    icmp
    string check = 1;
    string check_interval = 2;
    string alert_interval = 3;
    repeated AlertReceiver receivers = 4;
    map<string, string> vars = 5;
  }
}

message NodeAlert {
  Meta meta = 1;
  NodeAlertSpec spec = 2;

  message NodeAlertSpec {
    map<string, string> selector = 1;
    string node_name = 2;
    // Icinga CheckCommand name
    // Values are in
    //    influx_query
    //    node_disk
    //    node_status
    string check = 3;
    string check_interval = 4;
    string alert_interval = 5;
    repeated AlertReceiver receivers = 6;
    map<string, string> vars = 7;
  }
}

message PodAlert {
  Meta meta = 1;
  PodAlertSpec spec = 2;

  message PodAlertSpec {
    string selector = 1;
    string pod_name = 2;
    // Icinga CheckCommand name
    // Values are in
    //    influx_query
    //    pod_status
    //    volume
    //    kube_exec
    string check = 3;
    string check_interval = 4;
    string alert_interval = 5;
    repeated AlertReceiver receivers = 6;
    map<string, string> vars = 7;
  }
}

message AlertReceiver {
  string state = 1;
  repeated string to = 2;
  string notifier = 3;
}

message Role {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message RoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message ClusterRole {
  Meta meta = 1;
  repeated Rule rules = 2;
}

message ClusterRoleBinding {
  Meta meta = 1;
  repeated Subject subjects = 2;
  ObjectReference role_ref = 3;
}

message Rule {
  repeated string verbs = 1;
  repeated string api_groups = 2;
  repeated string resources = 3;
  repeated string resource_names = 4;
  repeated string non_resource_urls = 5;
}

message Subject {
  string kind = 1;
  string api_group = 2;
  string name = 3;
  string namespace = 4;
}

message Restic {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;
  message Spec {
    string selector = 1;
    repeated FileGroup file_groups = 2;
    Backend backend = 3;
    string schedule = 4;
    string use_auto_prefix = 5;
    repeated VolumeMount volume_mounts = 6;

    message FileGroup {
      string path = 1;
      repeated string tags = 2;
      RetentionPolicy retention_policy = 3;
    }
    message RetentionPolicy {
      int32 keep_last = 1;
      int32 keep_hourly = 2;
      int32 keep_daily = 3;
      int32 keep_weekly = 4;
      int32 keep_monthly = 5;
      int32 keep_yearly = 6;
      repeated string keep_tags = 7;
      bool prune = 8;
      bool dry_run = 9;
    }

    message Backend {
      string  storage_secret_name = 1;
      oneof storage {
        LocalSpec Local = 2;
        S3Spec S3 = 3;
        GCSSpec GCS = 4;
        AzureSpec Azure = 5;
        SwiftSpec Swift = 6;
      }
    }

    message LocalSpec {
        VolumeSource volumeSource = 1;
        string path = 2;
    }

    message S3Spec {
        string endpoint = 1;
        string bucket = 2;
        string prefix = 3;
    }

    message GCSSpec {
        string bucket = 1;
        string prefix = 2;
    }

    message AzureSpec {
        string container = 1;
        string prefix = 2;
    }

    message SwiftSpec {
        string container = 1;
        string prefix = 2;
    }
  }

  message Status {
    int64 first_backup_time = 1;
    int64 last_backup_time = 2;
    int64 last_successful_backup_time = 3;
    string last_backup_duration = 4;
    int64 backup_count = 5;
  }
}

message CronJob {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    string schedule = 1;
    int64 starting_deadline_seconds = 2;
    string concurrency_policy = 3;
    bool suspend = 4;
    JobSpec template = 5;
  }

  message Status {
    repeated ObjectReference active = 1;
    int64 last_schedule_time = 2;
  }
}

message Postgres {
  Meta meta = 1;
  PostgresSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message PostgresSpec {
  string version = 1;
  PersistentVolumeClaimSpec storage = 2;
  SecretVolumeSource database_secret = 3;
  map<string, string> node_selector = 4;
  InitSpec init = 5;
  BackupScheduleSpec backup_schedule = 6;
  bool do_not_pause = 7;
}

message Elasticsearch {
  Meta meta = 1;
  ElasticsearchSpec spec = 2;
  Status status = 3;

  message Status {
    int64 creation_time = 1;
    string phase = 2;
    string reason  = 3;
  }
}

message ElasticsearchSpec {
  string version = 1;
  int32 replicas = 2;
  PersistentVolumeClaimSpec storage = 3;
  map<string, string> node_selector = 4;
  InitSpec init = 5;
  BackupScheduleSpec backup_schedule = 6;
  bool do_not_pause = 7;
}

message DormantDatabase {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    bool wipe_out = 1;
    bool resume = 2;
    Origin origin = 3;
  }

  message Status {
    int64 creation_time = 1;
    int64 pausing_time = 2;
    int64 wipe_out_time = 3;
    string phase = 4;
    string reason = 5;
  }
}

message Origin {
  Meta meta = 1;
  Spec spec = 2;

  message Spec {
    ElasticsearchSpec elasticsearch = 1;
    PostgresSpec postgres = 2;
  }
}

message Snapshot {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    string database_name = 1;
    SnapshotStorageSpec snapshot_storage_spec = 2;
  }

  message Status {
    int64 start_time = 1;
    int64 completion_time = 2;
    string phase = 3;
    string reason = 4;
  }
}

message InitSpec {
  ScriptSourceSpec script_source = 1;
  SnapshotSourceSpec snapshot_source = 2;
}

message ScriptSourceSpec {
  string script_path = 1;
  VolumeSource volume_source = 2;
}

message SnapshotSourceSpec {
  string namespace = 1;
  string name = 2;
}

message BackupScheduleSpec {
  string cron_expression = 1;
  SnapshotStorageSpec snapshot_storage_spec = 2;
}

message SnapshotStorageSpec {
  string storage_secret_name = 1;
  oneof storage {
    LocalSpec Local = 2;
    S3Spec S3 = 3;
    GCSSpec GCS = 4;
    AzureSpec Azure = 5;
    SwiftSpec Swift = 6;
  }

  message LocalSpec {
    VolumeSource volumeSource = 1;
    string path = 2;
  }

  message S3Spec {
    string endpoint = 1;
    string bucket = 2;
    string prefix = 3;
  }

  message GCSSpec {
    string bucket = 1;
    string prefix = 2;
  }

  message AzureSpec {
    string container = 1;
    string prefix = 2;
  }

  message SwiftSpec {
    string container = 1;
    string prefix = 2;
  }
}

message Certificate {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    // Obtain a single certificate for all the domains. The first Domain provided wiil
    // be counted as Name and other domains will be in SANs.
    repeated string domains = 1;

    // Provider to resolve challange. Valid Providers are
    // "http":
    // "cloudflare":
    // "digitalocean":
    // "dnsimple":
    // "dyn":
    // "gandi":
    // "googlecloud":
    // "linode":
    // "namecheap":
    // "ovh":
    // "pdns":
    // "rfc2136":
    // "route53":
    // "vultr":
    string provider = 2;
    string email = 3;
    ObjectReference HTTP_provider_ingress_reference = 4;

    // ProviderCredentialSecret Must Contain Secrets for that specific Providers.
    // All the Key names for DNS providers needs to maintain the following formate:
    //
    // http
    // HTTP Provider needs an Ingress or ExtendedIngress reference in HTTP_provider_ingress_reference.
    //
    // cloudflare
    // CLOUDFLARE_EMAIL: The email of the cloudflare user
    // CLOUDFLARE_API_KEY: The API key corresponding to the email
    // 
    // digitalocean
    // DO_AUTH_TOKEN: The digital ocean authorization token
    // 
    // dnsimple
    // DNSIMPLE_EMAIL: The email fo the DNSimple user
    // DNSIMPLE_API_KEY: The API key corresponding to the email
    // 
    // dnsmadeeasy
    // DNSMADEEASY_API_KEY: The API key for DNS Made Easy
    // DNSMADEEASY_API_SECRET: The api secret corresponding with the API key
    // DNSMADEEASY_SANDBOX: A boolean flag, if set to true or 1, requests will be sent to the sandbox API
    // 
    // dyn
    // DYN_CUSTOMER_NAME: The customer name of the Dyn user
    // DYN_USER_NAME: The user name of the Dyn user
    // DYN_PASSWORD: The password of the Dyn user
    // 
    // gandi
    // GANDI_API_KEY: The API key for Gandi
    // 
    // googlecloud
    // GCE_PROJECT: The name of the Google Cloud project to use
    //
    // linode
    // LINODE_API_KEY: API key for linode
    //
    // namecheap
    // NAMECHEAP_API_USER: The username of the namecheap user
    // NAMECHEAP_API_KEY: The API key corresponding with the namecheap user
    // 
    // ovh
    // OVH_ENDPOINT: The URL of the API endpoint to use
    // OVH_APPLICATION_KEY: The application key
    // OVH_APPLICATION_SECRET: The secret corresponding to the application key
    // OVH_CONSUMER_KEY: The consumer key
    // 
    // pdns
    // PDNS_API_KEY: The API key to use
    // 
    // rfc2136
    // RFC2136_NAMESERVER: The network address of the provider, in the form of "host" or "host:port"
    // RFC2136_TSIG_ALGORITHM: The algorithm to use for TSIG authentication.
    // RFC2136_TSIG_KEY: The key to use for TSIG authentication.
    // RFC2136_TSIG_SECRET: The secret to use for TSIG authentication.
    // 
    // route53
    // AWS_ACCESS_KEY_ID: The access key ID
    // AWS_SECRET_ACCESS_KEY: The secret corresponding to the access key
    // 
    // vultr
    // VULTR_API_KEY: The API key to use
    string provider_credential_secret_name = 5;
    string ACME_user_secret_name = 6;

    // Provides Custom acme server url to issue certificates. If empty it
    // uses let's encrypt servers.
    string ACME_serverURL = 7;
  }

  message Status {
    bool certificate_obtained = 1;
    string message = 2;
    int64 creation_time = 3;
    string ACME_user_secret_name = 4;
    ACMECertificateDetails details = 5;

    message ACMECertificateDetails {
      string domain = 1;
      string certURL = 2;
      string cert_stableURL = 3;
      string account_ref = 4;
    }
  }
}

message DiskListRequest {
  string cluster=1;
}

message DiskListResponse {
  repeated Disk disks = 1;
}

message DiskDescribeRequest {
  string cluster = 1;
  string name = 2;
  string provider = 3;
}

message DiskDescribeResponse {
  Disk disk = 1;
}

message DiskCreateRequest {
  string cluster = 1;
  string name = 2;
  string zone = 3;
  string disk_type = 4;
  int64 size_gb = 5;
}

message DiskDeleteRequest {
  string cluster = 1;
  string uid = 2;
}

message Disk {
  string name = 1;
  string id = 2;
  string provider = 3;
  int64 size_gb = 4;
  string type = 5;
  string zone = 6;
  string status = 7;
  string endpoint = 8;
  int64 iops = 9;
  PersistentVolume persistent_volume = 10;
  PersistentVolumeClaim persistent_volume_claim = 11;
}

message ResourceCondition {
  string type = 1;
  string status = 2;
  int64 last_heartbeat_time = 3;
  int64 last_transition_time = 4;
  string reason = 5;
  string message = 6;
}

// Prometheus defines a Prometheus deployment.
message Prometheus {
  Meta meta = 1;
  PrometheusSpec spec = 2;
  PrometheusStatus status = 3;

  // Specification of the desired behavior of the Prometheus cluster.
  message PrometheusSpec {
    // ServiceMonitors to be selected for target discovery.
    string service_monitor_selector = 1;
    // Version of Prometheus to be deployed.
    string version = 2;
    // When a Prometheus deployment is paused, no actions except for deletion
    // will be performed on the underlying objects.
    bool paused = 3;
    // Base image to use for a Prometheus deployment.
    string base_image = 4;
    // An optional list of references to secrets in the same namespace
    // to use for pulling prometheus and alertmanager images from registries
    repeated LocalObjectReference image_pull_secrets = 5;
    // Number of instances to deploy for a Prometheus deployment.
    int32 replicas = 6;
    // Time duration Prometheus shall retain data for.
    string retention = 7;
    // The labels to add to any time series or alerts when communicating with
    // external systems (federation, remote storage, Alertmanager).
    map<string, string> external_labels = 8;
    // The external URL the Prometheus instances will be available under. This is
    // necessary to generate correct URLs. This is necessary if Prometheus is not
    // served from root of a DNS name.
    string external_url = 9;
    // The route prefix Prometheus registers HTTP handlers for. This is useful,
    // if using ExternalURL and a proxy is rewriting HTTP routes of a request,
    // and the actual ExternalURL is still true, but the server serves requests
    // under a different route prefix. For example for use with `kubectl proxy`.
    string route_prefix = 10;
    // A selector to select which ConfigMaps to mount for loading rule files from.
    string rule_selector = 11;
    // Define which Nodes the Pods are scheduled on.
    map<string, string> node_selector = 12;
    // ServiceAccountName is the name of the ServiceAccount to use to run the
    // Prometheus Pods.
    string service_account_name = 13;
    // Secrets is a list of Secrets in the same namespace as the Prometheus
    // object, which shall be mounted into the Prometheus Pods.
    // The Secrets are mounted into /etc/prometheus/secrets/<secret-name>.
    // Secrets changes after initial creation of a Prometheus object are not
    // reflected in the running Pods. To change the secrets mounted into the
    // Prometheus Pods, the object must be deleted and recreated with the new list
    // of secrets.
    repeated string secrets = 14;
    // Define details regarding alerting.
    AlertSpec alerting = 15;
  }

  message PrometheusStatus {
    // Represents whether any actions on the underlaying managed objects are
    // being performed. Only delete actions will be performed.
    bool paused = 1;
    // Total number of non-terminated pods targeted by this Prometheus deployment
    // (their labels match the selector).
    int32 replicas = 2;
    int32 updated_replicas = 3;
    int32 available_replicas = 4;
    int32 unavailable_replicas = 5;
  }
}

// AlertingSpec defines parameters for alerting configuration of Prometheus servers.
message AlertSpec {
  // AlertmanagerEndpoints Prometheus should fire alerts against.
  repeated PrometheusAlertmanagerEndpoint alertmanager = 1;
}

// AlertmanagerEndpoints defines a selection of a single Endpoints object
// containing alertmanager IPs to fire alerts against.
message PrometheusAlertmanagerEndpoint {
  string namespace = 1;
  string name = 2;
  int32 port = 3;
  string scheme = 4;
  string path_prefix = 5;
}

// ServiceMonitor defines monitoring for a set of services.
message ServiceMonitor {
  Meta meta = 1;
  ServiceMonitorSpec spec = 2;

  // ServiceMonitorSpec contains specification parameters for a ServiceMonitor.
  message ServiceMonitorSpec {
    // The label to use to retrieve the job name from.
    string job_label = 1;
    repeated Endpoint endpoints = 2;
    // Selector to select Endpoints objects.
    string selector = 3;
    // Selector to select which namespaces the Endpoints objects are discovered from.
    NamespaceSelector namespace_selector = 4;
  }

  // Endpoint defines a scrapeable endpoint serving Prometheus metrics.
  message Endpoint {
    // Name of the service port this endpoint refers to. Mutually exclusive with targetPort.
    string port = 1;
    // Name or number of the target port of the endpoint. Mutually exclusive with port.
    string target_port = 2;
    // HTTP path to scrape for metrics.
    string path = 3;
    // HTTP scheme to use for scraping.
    string scheme = 4;
    // Interval at which metrics should be scraped
    string interval = 5;
  }

  message NamespaceSelector {
    // Boolean describing whether all namespaces are selected in contrast to a
    // list restricting them.
    bool any = 1;
    // List of namespace names.
    repeated string match_names = 2;
  }
}

message ResourceRequirements {
  map<string, string> limits = 1;
  map<string, string> requests = 2;
}

message Ingress {
  Meta meta = 1;
  Spec spec = 2;
  Status status = 3;

  message Spec {
    HTTPIngressBackend backend = 1;
    repeated IngressTLS TLS = 2;
    repeated FrontendRule frontend_rules = 3;
    repeated IngressRule rules = 4;
    repeated string load_balancer_source_ranges = 5;
    ResourceRequirements resources = 6;
    Affinity affinity = 7;
    string scheduler_name = 8;
    repeated Toleration tolerations = 9;
  }

  message FrontendRule {
    int32 port = 1;
    repeated string rules = 2;
  }

  message Toleration {
    string key = 1;
    string operator = 2;
    string value = 3;
    string effect = 4;
    int64 toleration_seconds = 5;
  }

  message Affinity {
    NodeAffinity node_affinity = 1;
    PodAffinity pod_affinity = 2;
    PodAntiAffinity pod_anti_affinity = 3;
  }

  message NodeAffinity {
    NodeSelector required_during_scheduling_ignored_during_execution = 1;
    repeated PreferredSchedulingTerm preferred_during_scheduling_ignored_during_execution = 2;
  }

  message PreferredSchedulingTerm {
    int32 weight = 1;
    NodeSelectorTerm preference = 2;
  }

  message NodeSelector {
    repeated NodeSelectorTerm node_selector_terms = 1;
  }

  message NodeSelectorTerm {
    repeated NodeSelectorRequirement match_expressions = 1;
  }

  message NodeSelectorRequirement {
    string key = 1;
    string operator = 2;
    repeated string values = 3;
  }

  message PodAffinity {
    repeated PodAffinityTerm required_during_scheduling_ignored_during_execution = 1;
    repeated WeightedPodAffinityTerm preferred_during_scheduling_ignored_during_execution = 2;
  }

  message PodAffinityTerm {
    LabelSelector label_selector = 1;
    repeated string namespaces = 2;
    string topology_key = 3;
  }

  message LabelSelector {
    map<string, string> match_labels = 1;
    repeated LabelSelectorRequirement match_expressions = 2;
  }

  message LabelSelectorRequirement {
    string key = 1;
    string operator = 2;
    repeated string values = 3;
  }

  message WeightedPodAffinityTerm {
    int32 weight = 1;
    PodAffinityTerm pod_affinity_term = 2;
  }

  message PodAntiAffinity {
    repeated PodAffinityTerm required_during_scheduling_ignored_during_execution = 1;
    repeated WeightedPodAffinityTerm preferred_during_scheduling_ignored_during_execution = 2;
  }

  message HTTPIngressBackend {
    repeated string host_names = 1;
    string service_name = 2;
    int32 service_port = 3;
    repeated string backend_rule = 4;
    repeated string rewrite_rule = 5;
    repeated string header_rule = 6;
  }

  message Status {
    repeated LoadBalancerIngress load_balancer = 1;
  }

  message LoadBalancerIngress {
    string host_name = 1;
    string IP = 2;
  }

  message IngressTLS {
    repeated string hosts = 1;
    string secret_name = 2;
  }

  message IngressRule {
    string host = 1;
    HTTPIngressRuleValue HTTP = 2;
    TCPIngressRuleValue TCP = 3;
  }

  message HTTPIngressRuleValue {
    int32 port = 1;
    bool no_TLS = 2;
    int32 node_port = 3;
    repeated HTTPIngressPath paths = 4;
  }

  message TCPIngressRuleValue {
    int32 port = 1;
    bool no_TLS = 2;
    int32 node_port = 3;
    IngressBackend backend = 4;
    repeated string ALPN = 5;
  }

  message HTTPIngressPath {
    string path = 1;
    HTTPIngressBackend backend = 2;
  }

  message IngressBackend {
    repeated string host_names = 1;
    string service_name = 2;
    int32 service_port = 3;
    repeated string backend_rule = 4;
  }
}

// TODO
// The following values are copied from kubernetes/pkg/api/v1/generated.proto
// Those values should be removed and use by importing those protobuf
// while kubernetes completely moved to protobuf.

// Represents the source of a volume to mount.
// Only one of its members may be specified.
message VolumeSource {
  // HostPath represents a pre-existing file or directory on the host
  // machine that is directly exposed to the container. This is generally
  // used for system agents or other privileged things that are allowed
  // to see the host machine. Most containers will NOT need this.
  // More info: http://kubernetes.io/docs/user-guide/volumes#hostpath
  // ---
  // TODO(jonesdl) We need to restrict who can use host directory mounts and who can/can not
  // mount host directories as read/write.
  // +optional
  HostPathVolumeSource hostPath = 1;

  // EmptyDir represents a temporary directory that shares a pod's lifetime.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  // +optional
  EmptyDirVolumeSource emptyDir = 2;

  // GCEPersistentDisk represents a GCE Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: http://kubernetes.io/docs/user-guide/volumes#gcepersistentdisk
  // +optional
  GCEPersistentDiskVolumeSource gcePersistentDisk = 3;

  // AWSElasticBlockStore represents an AWS Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: http://kubernetes.io/docs/user-guide/volumes#awselasticblockstore
  // +optional
  AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;

  // GitRepo represents a git repository at a particular revision.
  // +optional
  GitRepoVolumeSource gitRepo = 5;

  // Secret represents a secret that should populate this volume.
  // More info: http://kubernetes.io/docs/user-guide/volumes#secrets
  // +optional
  SecretVolumeSource secret = 6;

  // NFS represents an NFS mount on the host that shares a pod's lifetime
  // More info: http://kubernetes.io/docs/user-guide/volumes#nfs
  // +optional
  NFSVolumeSource nfs = 7;

  // ISCSI represents an ISCSI Disk resource that is attached to a
  // kubelet's host machine and then exposed to the pod.
  // More info: http://releases.k8s.io/HEAD/examples/volumes/iscsi/README.md
  // +optional
  ISCSIVolumeSource iscsi = 8;

  // Glusterfs represents a Glusterfs mount on the host that shares a pod's lifetime.
  // More info: http://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
  // +optional
  GlusterfsVolumeSource glusterfs = 9;

  // PersistentVolumeClaimVolumeSource represents a reference to a
  // PersistentVolumeClaim in the same namespace.
  // More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
  // +optional
  PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;

  // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime.
  // More info: http://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
  // +optional
  RBDVolumeSource rbd = 11;

  // FlexVolume represents a generic volume resource that is
  // provisioned/attached using an exec based plugin. This is an
  // alpha feature and may change in future.
  // +optional
  FlexVolumeSource flexVolume = 12;

  // Cinder represents a cinder volume attached and mounted on kubelets host machine
  // More info: http://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
  // +optional
  CinderVolumeSource cinder = 13;

  // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
  // +optional
  CephFSVolumeSource cephfs = 14;

  // Flocker represents a Flocker volume attached to a kubelet's host machine. This depends on the Flocker control service being running
  // +optional
  FlockerVolumeSource flocker = 15;

  // DownwardAPI represents downward API about the pod that should populate this volume
  // +optional
  DownwardAPIVolumeSource downwardAPI = 16;

  // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
  // +optional
  FCVolumeSource fc = 17;

  // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
  // +optional
  AzureFileVolumeSource azureFile = 18;

  // ConfigMap represents a configMap that should populate this volume
  // +optional
  ConfigMapVolumeSource configMap = 19;

  // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
  // +optional
  VsphereVirtualDiskVolumeSource vsphereVolume = 20;

  // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
  // +optional
  QuobyteVolumeSource quobyte = 21;

  // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
  // +optional
  AzureDiskVolumeSource azureDisk = 22;

  // PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
  PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;
}

// Represents a Persistent Disk resource in AWS.
//
// An AWS EBS disk must exist before mounting to a container. The disk
// must also be in the same AWS zone as the kubelet. An AWS EBS disk
// can only be mounted as read/write once. AWS EBS volumes support
// ownership management and SELinux relabeling.
message AWSElasticBlockStoreVolumeSource {
  // Unique ID of the persistent disk resource in AWS (Amazon EBS volume).
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  string volumeID = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  int32 partition = 3;

  // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true".
  // If omitted, the default is "false".
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#awselasticblockstore
  bool readOnly = 4;
}

// Represents a host path mapped into a pod.
// Host path volumes do not support ownership management or SELinux relabeling.
message HostPathVolumeSource {
  // Path of the directory on the host.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#hostpath
  string path = 1;
}

// Adapts a Secret into a volume.
//
// The contents of the target Secret's Data field will be presented in a volume
// as files using the keys in the Data field as the file names.
// Secret volumes support ownership management and SELinux relabeling.
message SecretVolumeSource {
  // Name of the secret in the pod's namespace to use.
  // More info: http://kubernetes.io/docs/user-guide/volumes#secrets
  string secretName = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // Secret will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the Secret,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  repeated KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  int32 defaultMode = 3;
}

// Maps a string key to a path within a volume.
message KeyToPath {
  // The key to project.
  string key = 1;

  // The relative path of the file to map the key to.
  // May not be an absolute path.
  // May not contain the path element '..'.
  // May not start with the string '..'.
  string path = 2;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 mode = 3;
}

// Represents an empty directory for a pod.
// Empty directory volumes support ownership management and SELinux relabeling.
message EmptyDirVolumeSource {
  // What type of storage medium should back this directory.
  // The default is "" which means to use the node's default medium.
  // Must be an empty string (default) or Memory.
  // More info: http://kubernetes.io/docs/user-guide/volumes#emptydir
  string medium = 1;
}

// PersistentVolumeClaimVolumeSource references the user's PVC in the same namespace.
// This volume finds the bound PV and mounts that volume for the pod. A
// PersistentVolumeClaimVolumeSource is, essentially, a wrapper around another
// type of volume that is owned by someone else (the system).
message PersistentVolumeClaimVolumeSource {
  // ClaimName is the name of a PersistentVolumeClaim in the same namespace as the pod using this volume.
  // More info: http://kubernetes.io/docs/user-guide/persistent-volumes#persistentvolumeclaims
  string claimName = 1;

  // Will force the ReadOnly setting in VolumeMounts.
  // Default false.
  // +optional
  bool readOnly = 2;
}

// DownwardAPIVolumeSource represents a volume containing downward API info.
// Downward API volumes support ownership management and SELinux relabeling.
message DownwardAPIVolumeSource {
  // Items is a list of downward API volume file
  // +optional
  repeated DownwardAPIVolumeFile items = 1;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 defaultMode = 2;
}

// DownwardAPIVolumeFile represents information to create the file containing the pod field
message DownwardAPIVolumeFile {
  // Required: Path is  the relative path name of the file to be created. Must not be absolute or contain the '..' path. Must be utf-8 encoded. The first item of the relative path must not start with '..'
  string path = 1;

  // Required: Selects a field of the pod: only annotations, labels, name and namespace are supported.
  // +optional
  ObjectFieldSelector fieldRef = 2;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  ResourceFieldSelector resourceFieldRef = 3;

  // Optional: mode bits to use on this file, must be a value between 0
  // and 0777. If not specified, the volume defaultMode will be used.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 mode = 4;
}

message ConfigMapVolumeSource {
  LocalObjectReference localObjectReference = 1;

  // If unspecified, each key-value pair in the Data field of the referenced
  // ConfigMap will be projected into the volume as a file whose name is the
  // key and content is the value. If specified, the listed keys will be
  // projected into the specified paths, and unlisted keys will not be
  // present. If a key is specified which is not present in the ConfigMap,
  // the volume setup will error unless it is marked optional. Paths must be
  // relative and may not contain the '..' path or start with '..'.
  // +optional
  KeyToPath items = 2;

  // Optional: mode bits to use on created files by default. Must be a
  // value between 0 and 0777. Defaults to 0644.
  // Directories within the path are not affected by this setting.
  // This might be in conflict with other options that affect the file
  // mode, like fsGroup, and the result can be other mode bits set.
  // +optional
  int32 defaultMode = 3;

  // Specify whether the ConfigMap or it's keys must be defined
  // +optional
  bool optional = 4;
}

// Represents a Photon Controller persistent disk resource.
message PhotonPersistentDiskVolumeSource {
  // ID that identifies Photon Controller persistent disk
  string pdID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 2;
}

// LocalObjectReference contains enough information to let you locate the
// referenced object inside the same namespace.
message LocalObjectReference {
  // Name of the referent.
  // More info: http://kubernetes.io/docs/user-guide/identifiers#names
  // TODO: Add other useful fields. apiVersion, kind, uid?
  // +optional
  string name = 1;
}

// Represents an NFS mount that lasts the lifetime of a pod.
// NFS volumes do not support ownership management or SELinux relabeling.
message NFSVolumeSource {
  // Server is the hostname or IP address of the NFS server.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  string server = 1;

  // Path that is exported by the NFS server.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  string path = 2;

  // ReadOnly here will force
  // the NFS export to be mounted with read-only permissions.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#nfs
  bool readOnly = 3;
}

// Represents a Fibre Channel volume.
// Fibre Channel volumes can only be mounted as read/write once.
// Fibre Channel volumes support ownership management and SELinux relabeling.
message FCVolumeSource {
  // Required: FC target worldwide names (WWNs)
  repeated string targetWWNs = 1;

  // Required: FC target lun number
  int32 lun = 2;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 4;
}

// FlexVolume represents a generic volume resource that is
// provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
message FlexVolumeSource {
  // Driver is the name of the driver to use for this volume.
  string driver = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
  string fsType = 2;

  // Optional: SecretRef is reference to the secret object containing
  // sensitive information to pass to the plugin scripts. This may be
  // empty if no secret object is specified. If the secret object
  // contains more than one secret, all secrets are passed to the plugin
  // scripts.
  ObjectReference secretRef = 3;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 4;

  // Optional: Extra command options if any.
  map<string, string> options = 5;
}

// Represents a Flocker volume mounted by the Flocker agent.
// Flocker volumes do not support ownership management or SELinux relabeling.
message FlockerVolumeSource {
  // Required: the volume name. This is going to be store on metadata -> name on the payload for Flocker
  string datasetName = 1;
}

// Represents a Persistent Disk resource in Google Compute Engine.
//
// A GCE PD must exist before mounting to a container. The disk must
// also be in the same GCE project and zone as the kubelet. A GCE PD
// can only be mounted as read/write once or read-only many times. GCE
// PDs support ownership management and SELinux relabeling.
message GCEPersistentDiskVolumeSource {
  // Unique name of the PD resource in GCE. Used to identify the disk in GCE.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  string pdName = 1;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 2;

  // The partition in the volume that you want to mount.
  // If omitted, the default is to mount by volume name.
  // Examples: For volume /dev/sda1, you specify the partition as "1".
  // Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  int32 partition = 3;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#gcepersistentdisk
  bool readOnly = 4;
}

// Represents a volume that is populated with the contents of a git repository.
// Git repo volumes do not support ownership management.
// Git repo volumes support SELinux relabeling.
message GitRepoVolumeSource {
  // Repository URL
  string repository = 1;

  // Commit hash for the specified revision.
  string revision = 2;

  // Target directory name.
  // Must not contain or start with '..'.  If '.' is supplied, the volume directory will be the
  // git repository.  Otherwise, if specified, the volume will contain the git repository in
  // the subdirectory with the given name.
  string directory = 3;
}

// Represents a Glusterfs mount that lasts the lifetime of a pod.
// Glusterfs volumes do not support ownership management or SELinux relabeling.
message GlusterfsVolumeSource {
  // EndpointsName is the endpoint name that details Glusterfs topology.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  string endpoints = 1;

  // Path is the Glusterfs volume path.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  string path = 2;

  // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/glusterfs/README.md#create-a-pod
  bool readOnly = 3;
}

// Represents a Rados Block Device mount that lasts the lifetime of a pod.
// RBD volumes support ownership management and SELinux relabeling.
message RBDVolumeSource {
  // A collection of Ceph monitors.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  repeated string monitors = 1;

  // The rados image name.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string image = 2;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#rbd
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 3;

  // The rados pool name.
  // Default is rbd.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it.
  string pool = 4;

  // The rados user name.
  // Default is admin.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string user = 5;

  // Keyring is the path to key ring for RBDUser.
  // Default is /etc/ceph/keyring.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  string keyring = 6;

  // SecretRef is name of the authentication secret for RBDUser. If provided
  // overrides keyring.
  // Default is nil.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  ObjectReference secretRef = 7;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/rbd/README.md#how-to-use-it
  bool readOnly = 8;
}

// Represents an ISCSI disk.
// ISCSI volumes can only be mounted as read/write once.
// ISCSI volumes support ownership management and SELinux relabeling.
message ISCSIVolumeSource {
  // iSCSI target portal. The portal is either an IP or ip_addr:port if the port
  // is other than default (typically TCP ports 860 and 3260).
  string targetPortal = 1;

  // Target iSCSI Qualified Name.
  string iqn = 2;

  // iSCSI target lun number.
  int32 lun = 3;

  // Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
  string iscsiInterface = 4;

  // Filesystem type of the volume that you want to mount.
  // Tip: Ensure that the filesystem type is supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/docs/user-guide/volumes.md#iscsi
  // TODO: how do we prevent errors in the filesystem from compromising the machine
  string fsType = 5;

  // ReadOnly here will force the ReadOnly setting in VolumeMounts.
  // Defaults to false.
  bool readOnly = 6;
}

// AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
message AzureFileVolumeSource {
  // the name of secret that contains Azure Storage Account Name and Key
  string secretName = 1;

  // Share Name
  string shareName = 2;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 3;
}

// Represents a vSphere volume resource.
message VsphereVirtualDiskVolumeSource {
  // Path that identifies vSphere volume vmdk
  string volumePath = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 2;
}

// Represents a Quobyte mount that lasts the lifetime of a pod.
// Quobyte volumes do not support ownership management or SELinux relabeling.
message QuobyteVolumeSource {
  // Registry represents a single or multiple Quobyte Registry services
  // specified as a string as host:port pair (multiple entries are separated with commas)
  // which acts as the central registry for volumes
  string registry = 1;

  // Volume is a string that references an already created Quobyte volume by name.
  string volume = 2;

  // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions.
  // Defaults to false.
  bool readOnly = 3;

  // User to map volume access to
  // Defaults to serivceaccount user
  string user = 4;

  // Group to map volume access to
  // Default is no group
  string group = 5;
}

// AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
message AzureDiskVolumeSource {
  // The Name of the data disk in the blob storage
  string diskName = 1;

  // The URI the data disk in the blob storage
  string diskURI = 2;

  // Host Caching mode: None, Read Only, Read Write.
  string cachingMode = 3;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  string fsType = 4;

  // Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  bool readOnly = 5;
}

// Represents a cinder volume resource in Openstack.
// A Cinder volume must exist before mounting to a container.
// The volume must also be in the same region as the kubelet.
// Cinder volumes support ownership management and SELinux relabeling.
message CinderVolumeSource {
  // volume id used to identify the volume in cinder
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  string volumeID = 1;

  // Filesystem type to mount.
  // Must be a filesystem type supported by the host operating system.
  // Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  string fsType = 2;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/release-1.4/examples/mysql-cinder-pd/README.md
  bool readOnly = 3;
}

// Represents a Ceph Filesystem mount that lasts the lifetime of a pod
// Cephfs volumes do not support ownership management or SELinux relabeling.
message CephFSVolumeSource {
  // Required: Monitors is a collection of Ceph monitors
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  repeated string monitors = 1;

  // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
  string path = 2;

  // Optional: User is the rados user name, default is admin
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  string user = 3;

  // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  string secretFile = 4;

  // Optional: SecretRef is reference to the authentication secret for User, default is empty.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  ObjectReference secretRef = 5;

  // Optional: Defaults to false (read/write). ReadOnly here will force
  // the ReadOnly setting in VolumeMounts.
  // More info: http://releases.k8s.io/release-1.4/examples/volumes/cephfs/README.md#how-to-use-it
  bool readOnly = 6;
}

message EnvVar {
  // Name of the environment variable. Must be a C_IDENTIFIER.
  string name = 1;

  // Variable references $(VAR_NAME) are expanded
  // using the previous defined environment variables in the container and
  // any service environment variables. If a variable cannot be resolved,
  // the reference in the input string will be unchanged. The $(VAR_NAME)
  // syntax can be escaped with a double $$, ie: $$(VAR_NAME). Escaped
  // references will never be expanded, regardless of whether the variable
  // exists or not.
  // Defaults to "".
  // +optional
  string value = 2;

  // Source for the environment variable's value. Cannot be used if value is not empty.
  // +optional
  EnvVarSource value_from = 3;
}

// EnvVarSource represents a source for the value of an EnvVar.
message EnvVarSource {
  // Selects a field of the pod: supports metadata.name, metadata.namespace, metadata.labels, metadata.annotations,
  // spec.nodeName, spec.serviceAccountName, status.podIP.
  // +optional
  ObjectFieldSelector field_ref = 1;

  // Selects a resource of the container: only resources limits and requests
  // (limits.cpu, limits.memory, requests.cpu and requests.memory) are currently supported.
  // +optional
  ResourceFieldSelector resource_field_ref = 2;

  // Selects a key of a ConfigMap.
  // +optional
  ConfigMapKeySelector config_map_key_ref = 3;

  // Selects a key of a secret in the pod's namespace
  // +optional
  SecretKeySelector secret_key_ref = 4;
}

// ObjectFieldSelector selects an APIVersioned field of an object.
message ObjectFieldSelector {
  // Version of the schema the FieldPath is written in terms of, defaults to "v1".
  // +optional
  string api_version = 1;

  // Path of the field to select in the specified API version.
  string field_path = 2;
}

// ResourceFieldSelector represents container resources (cpu, memory) and their output format
message ResourceFieldSelector {
  // Container name: required for volumes, optional for env vars
  // +optional
  string container_name = 1;

  // Required: resource to select
  string resource = 2;

  // Specifies the output format of the exposed resources, defaults to "1"
  // +optional
  string divisor = 3;
}

// Selects a key from a ConfigMap.
message ConfigMapKeySelector {
  // The ConfigMap to select from.
  ObjectReference local_object_reference = 1;

  // The key to select.
  string key = 2;
}

// SecretKeySelector selects a key of a Secret.
message SecretKeySelector {
  // The name of the secret in the pod's namespace to select from.
  ObjectReference local_object_reference = 1;

  // The key of the secret to select from.  Must be a valid secret key.
  string key = 2;
}