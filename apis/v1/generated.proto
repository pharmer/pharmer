/*
Copyright 2018 The Pharmer Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/


// This file was autogenerated by go-to-protobuf. Do not edit it manually!

syntax = 'proto2';

package github.com.pharmer.pharmer.apis.v1;

import "github.com/gogo/protobuf/gogoproto/gogo.proto";
import "k8s.io/api/core/v1/generated.proto";
import "k8s.io/apimachinery/pkg/apis/meta/v1/generated.proto";

// Package-wide variables from generator "generated".
option (gogoproto.marshaler_all) = true;
option (gogoproto.stable_marshaler_all) = true;
option (gogoproto.sizer_all) = true;
option (gogoproto.goproto_stringer_all) = false;
option (gogoproto.stringer_all) = true;
option (gogoproto.unmarshaler_all) = true;
option (gogoproto.goproto_unrecognized_all) = false;
option (gogoproto.goproto_enum_prefix_all) = false;
option (gogoproto.goproto_getters_all) = false;
option go_package = "v1";

message APIEndpoint {
  // The hostname on which the API server is serving.
  optional string host = 1 [(gogoproto.customname) = "Host", (gogoproto.nullable) = false];

  // The port on which the API server is serving.
  optional int64 port = 2 [(gogoproto.customname) = "Port", (gogoproto.nullable) = false];
}

message Cluster {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional ClusterSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];

  optional ClusterStatus status = 3 [(gogoproto.customname) = "Status", (gogoproto.nullable) = false];
}

message ClusterNetworkingConfig {
  // The network ranges from which service VIPs are allocated.
  optional NetworkRanges services = 1 [(gogoproto.customname) = "Services", (gogoproto.nullable) = false];

  // The network ranges from which POD networks are allocated.
  optional NetworkRanges pods = 2 [(gogoproto.customname) = "Pods", (gogoproto.nullable) = false];

  // Domain name for services.
  optional string serviceDomain = 3 [(gogoproto.customname) = "ServiceDomain", (gogoproto.nullable) = false];
}

message ClusterSpec {
  // Cluster network configuration
  optional ClusterNetworkingConfig clusterNetwork = 1 [(gogoproto.customname) = "ClusterNetwork", (gogoproto.nullable) = false];

  // Provider-specific serialized configuration to use during
  // cluster creation. It is recommended that providers maintain
  // their own versioned API types that should be
  // serialized/deserialized from this field.
  // +optional
  optional ProviderConfig providerConfig = 2 [(gogoproto.customname) = "ProviderConfig", (gogoproto.nullable) = false];
}

message ClusterStatus {
  // APIEndpoint represents the endpoint to communicate with the IP.
  repeated APIEndpoint apiEndpoints = 1 [(gogoproto.customname) = "APIEndpoints", (gogoproto.nullable) = false];

  // If set, indicates that there is a problem reconciling the
  // state, and will be set to a token value suitable for
  // programmatic interpretation.
  optional string errorReason = 2 [(gogoproto.casttype) = "sigs.k8s.io/cluster-api/pkg/apis/cluster/common.ClusterStatusError", (gogoproto.customname) = "ErrorReason", (gogoproto.nullable) = false];

  // If set, indicates that there is a problem reconciling the
  // state, and will be set to a descriptive error message.
  optional string errorMessage = 3 [(gogoproto.customname) = "ErrorMessage", (gogoproto.nullable) = false];

  // Provider-specific serialized status to use during cluster
  // creation. It is recommended that providers maintain their
  // own versioned API types that should be
  // serialized/deserialized from this field.
  optional string providerStatus = 4 [(gogoproto.customname) = "ProviderStatus", (gogoproto.nullable) = false];
}

message ContainerRuntimeInfo {
  // docker, rkt, containerd, ...
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Semantic version of the container runtime to use
  optional string version = 2 [(gogoproto.customname) = "Version", (gogoproto.nullable) = false];
}

message Machine {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional MachineSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];

  optional MachineStatus status = 3 [(gogoproto.customname) = "Status", (gogoproto.nullable) = false];
}

message MachineSpec {
  // This ObjectMeta will autopopulate the Node created. Use this to
  // indicate what labels, annotations, name prefix, etc., should be used
  // when creating the Node.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  // The full, authoritative list of taints to apply to the corresponding
  // Node. This list will overwrite any modifications made to the Node on
  // an ongoing basis.
  // +optional
  repeated k8s.io.api.core.v1.Taint taints = 2 [(gogoproto.customname) = "Taints", (gogoproto.nullable) = false];

  // Provider-specific configuration to use during node creation.
  // +optional
  optional ProviderConfig providerConfig = 3 [(gogoproto.customname) = "ProviderConfig", (gogoproto.nullable) = false];

  // A list of roles for this Machine to use.
  repeated string roles = 4 [(gogoproto.casttype) = "sigs.k8s.io/cluster-api/pkg/apis/cluster/common.MachineRole", (gogoproto.customname) = "Roles"];

  // Versions of key software to use. This field is optional at cluster
  // creation time, and omitting the field indicates that the cluster
  // installation tool should select defaults for the user. These
  // defaults may differ based on the cluster installer, but the tool
  // should populate the values it uses when persisting Machine objects.
  // A Machine spec missing this field at runtime is invalid.
  // +optional
  optional MachineVersionInfo versions = 5 [(gogoproto.customname) = "Versions", (gogoproto.nullable) = false];

  // To populate in the associated Node for dynamic kubelet config. This
  // field already exists in Node, so any updates to it in the Machine
  // spec will be automatially copied to the linked NodeRef from the
  // status. The rest of dynamic kubelet config support should then work
  // as-is.
  // +optional
  optional k8s.io.api.core.v1.NodeConfigSource configSource = 6 [(gogoproto.customname) = "ConfigSource"];
}

message MachineStatus {
  // If the corresponding Node exists, this will point to its object.
  // +optional
  optional k8s.io.api.core.v1.ObjectReference nodeRef = 1 [(gogoproto.customname) = "NodeRef"];

  // When was this status last observed
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.Time lastUpdated = 2 [(gogoproto.customname) = "LastUpdated", (gogoproto.nullable) = false];

  // The current versions of software on the corresponding Node (if it
  // exists). This is provided for a few reasons:
  // 
  // 1) It is more convenient than checking the NodeRef, traversing it to
  //    the Node, and finding the appropriate field in Node.Status.NodeInfo
  //    (which uses different field names and formatting).
  // 2) It removes some of the dependency on the structure of the Node,
  //    so that if the structure of Node.Status.NodeInfo changes, only
  //    machine controllers need to be updated, rather than every client
  //    of the Machines API.
  // 3) There is no other way simple way to check the ControlPlane
  //    version. A client would have to connect directly to the apiserver
  //    running on the target node in order to find out its version.
  // +optional
  optional MachineVersionInfo versions = 3 [(gogoproto.customname) = "Versions"];

  // In the event that there is a terminal problem reconciling the
  // Machine, both ErrorReason and ErrorMessage will be set. ErrorReason
  // will be populated with a succinct value suitable for machine
  // interpretation, while ErrorMessage will contain a more verbose
  // string suitable for logging and human consumption.
  // 
  // These fields should not be set for transitive errors that a
  // controller faces that are expected to be fixed automatically over
  // time (like service outages), but instead indicate that something is
  // fundamentally wrong with the Machine's spec or the configuration of
  // the controller, and that manual intervention is required. Examples
  // of terminal errors would be invalid combinations of settings in the
  // spec, values that are unsupported by the controller, or the
  // responsible controller itself being critically misconfigured.
  // 
  // Any transient errors that occur during the reconcilation of Machines
  // can be added as events to the Machine object and/or logged in the
  // controller's output.
  // +optional
  optional string errorReason = 4 [(gogoproto.casttype) = "sigs.k8s.io/cluster-api/pkg/apis/cluster/common.MachineStatusError", (gogoproto.customname) = "ErrorReason"];

  // +optional
  optional string errorMessage = 5 [(gogoproto.customname) = "ErrorMessage"];
}

message MachineVersionInfo {
  // Semantic version of kubelet to run
  optional string kubelet = 1 [(gogoproto.customname) = "Kubelet", (gogoproto.nullable) = false];

  // Semantic version of the Kubernetes control plane to
  // run. This should only be populated when the machine is a
  // master.
  // +optional
  optional string controlPlane = 2 [(gogoproto.customname) = "ControlPlane", (gogoproto.nullable) = false];

  // Name/version of container runtime
  optional ContainerRuntimeInfo containerRuntime = 3 [(gogoproto.customname) = "ContainerRuntime", (gogoproto.nullable) = false];
}

message NetworkRanges {
  repeated string cidrBlocks = 1 [(gogoproto.customname) = "CIDRBlocks"];
}

message ProviderConfig {
  // Value is an inlined, serialized representation of the resource
  // configuration. It is recommended that providers maintain their own
  // versioned API types that should be serialized/deserialized from this
  // field, akin to component config.
  // +optional
  optional k8s.io.apimachinery.pkg.apis.meta.v1.RawExtension value = 1 [(gogoproto.customname) = "Value"];

  // Source for the provider configuration. Cannot be used if value is
  // not empty.
  // +optional
  optional ProviderConfigSource valueFrom = 2 [(gogoproto.customname) = "ValueFrom"];
}

message ProviderConfigSource {
}

message API {
  // AdvertiseAddress sets the address for the API server to advertise.
  optional string advertiseAddress = 1 [(gogoproto.customname) = "AdvertiseAddress", (gogoproto.nullable) = false];

  // BindPort sets the secure port for the API Server to bind to
  optional int32 bindPort = 2 [(gogoproto.customname) = "BindPort", (gogoproto.nullable) = false];
}

message AWSSpec {
  // aws:TAG KubernetesCluster => clusterid
  optional string iamProfileMaster = 1 [(gogoproto.customname) = "IAMProfileMaster", (gogoproto.nullable) = false];

  optional string iamProfileNode = 2 [(gogoproto.customname) = "IAMProfileNode", (gogoproto.nullable) = false];

  optional string masterSGName = 3 [(gogoproto.customname) = "MasterSGName", (gogoproto.nullable) = false];

  optional string nodeSGName = 4 [(gogoproto.customname) = "NodeSGName", (gogoproto.nullable) = false];

  optional string vpcCIDR = 5 [(gogoproto.customname) = "VpcCIDR", (gogoproto.nullable) = false];

  optional string vpcCIDRBase = 6 [(gogoproto.customname) = "VpcCIDRBase", (gogoproto.nullable) = false];

  optional string masterIPSuffix = 7 [(gogoproto.customname) = "MasterIPSuffix", (gogoproto.nullable) = false];

  optional string subnetCidr = 8 [(gogoproto.customname) = "SubnetCIDR", (gogoproto.nullable) = false];
}

message Action {
  optional string action = 1 [(gogoproto.casttype) = "ActionType", (gogoproto.customname) = "Action", (gogoproto.nullable) = false];

  optional string resource = 2 [(gogoproto.customname) = "Resource", (gogoproto.nullable) = false];

  optional string message = 3 [(gogoproto.customname) = "Message", (gogoproto.nullable) = false];
}

message AzureSpec {
  optional string instanceImageVersion = 1 [(gogoproto.customname) = "InstanceImageVersion", (gogoproto.nullable) = false];

  optional string rootPassword = 2 [(gogoproto.customname) = "RootPassword", (gogoproto.nullable) = false];

  optional string subnetCidr = 3 [(gogoproto.customname) = "SubnetCIDR", (gogoproto.nullable) = false];

  optional string resourceGroup = 4 [(gogoproto.customname) = "ResourceGroup", (gogoproto.nullable) = false];

  optional string subnetName = 5 [(gogoproto.customname) = "SubnetName", (gogoproto.nullable) = false];

  optional string securityGroupName = 6 [(gogoproto.customname) = "SecurityGroupName", (gogoproto.nullable) = false];

  optional string vnetName = 7 [(gogoproto.customname) = "VnetName", (gogoproto.nullable) = false];

  optional string routeTableName = 8 [(gogoproto.customname) = "RouteTableName", (gogoproto.nullable) = false];

  optional string azureStorageAccountName = 9 [(gogoproto.customname) = "StorageAccountName", (gogoproto.nullable) = false];
}

message AzureStorageSpec {
  optional string container = 1 [(gogoproto.customname) = "Container", (gogoproto.nullable) = false];

  optional string prefix = 2 [(gogoproto.customname) = "Prefix", (gogoproto.nullable) = false];
}

message CloudStatus {
  optional string sshKeyExternalID = 1 [(gogoproto.customname) = "SShKeyExternalID", (gogoproto.nullable) = false];
}

message Cluster {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional PharmerClusterSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];

  optional PharmerClusterStatus status = 3 [(gogoproto.customname) = "Status", (gogoproto.nullable) = false];
}

message ClusterProviderConfig {
  optional string cloudProvider = 1 [(gogoproto.customname) = "CloudProvider", (gogoproto.nullable) = false];

  optional string project = 2 [(gogoproto.customname) = "Project", (gogoproto.nullable) = false];

  optional string region = 3 [(gogoproto.customname) = "Region", (gogoproto.nullable) = false];

  optional string zone = 4 [(gogoproto.customname) = "Zone", (gogoproto.nullable) = false];

  // master needs it for ossec
  optional string instanceImage = 5 [(gogoproto.customname) = "InstanceImage", (gogoproto.nullable) = false];

  optional string os = 6 [(gogoproto.customname) = "OS", (gogoproto.nullable) = false];

  optional string instanceImageProject = 7 [(gogoproto.customname) = "InstanceImageProject", (gogoproto.nullable) = false];

  optional string networkProvider = 8 [(gogoproto.customname) = "NetworkProvider", (gogoproto.nullable) = false];

  // kubenet, flannel, calico, opencontrail
  optional string ccmCredentialName = 9 [(gogoproto.customname) = "CCMCredentialName", (gogoproto.nullable) = false];

  optional string sshKeyName = 10 [(gogoproto.customname) = "SSHKeyName", (gogoproto.nullable) = false];

  optional AWSSpec aws = 11 [(gogoproto.customname) = "AWS"];

  optional GoogleSpec gce = 12 [(gogoproto.customname) = "GCE"];

  optional AzureSpec azure = 13 [(gogoproto.customname) = "Azure"];

  optional LinodeSpec linode = 14 [(gogoproto.customname) = "Linode"];

  optional GKESpec gke = 15 [(gogoproto.customname) = "GKE"];
}

message Credential {
  optional k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1 [(gogoproto.customname) = "ObjectMeta", (gogoproto.nullable) = false];

  optional CredentialSpec spec = 2 [(gogoproto.customname) = "Spec", (gogoproto.nullable) = false];
}

message CredentialSpec {
  optional string provider = 1 [(gogoproto.customname) = "Provider", (gogoproto.nullable) = false];

  map<string, string> data = 2 [(gogoproto.customname) = "Data", (gogoproto.nullable) = false];
}

message GCSSpec {
  optional string bucket = 1 [(gogoproto.customname) = "Bucket", (gogoproto.nullable) = false];

  optional string prefix = 2 [(gogoproto.customname) = "Prefix", (gogoproto.nullable) = false];
}

message GKESpec {
  optional string userName = 1 [(gogoproto.customname) = "UserName", (gogoproto.nullable) = false];

  optional string password = 2 [(gogoproto.customname) = "Password", (gogoproto.nullable) = false];

  optional string networkName = 3 [(gogoproto.customname) = "NetworkName", (gogoproto.nullable) = false];
}

message GoogleSpec {
  optional string networkName = 1 [(gogoproto.customname) = "NetworkName", (gogoproto.nullable) = false];

  repeated string nodeTags = 2 [(gogoproto.customname) = "NodeTags"];

  // gce
  // NODE_SCOPES="${NODE_SCOPES:-compute-rw,monitoring,logging-write,storage-ro}"
  repeated string nodeScopes = 3 [(gogoproto.customname) = "NodeScopes"];
}

// Config holds the information needed to build connect to remote kubernetes clusters as a given user
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
message KubeConfig {
  // Preferences holds general information to be use for cli interactions
  optional Preferences preferences = 1 [(gogoproto.customname) = "Preferences", (gogoproto.nullable) = false];

  // Clusters is a map of referencable names to cluster configs
  optional NamedCluster cluster = 2 [(gogoproto.customname) = "Cluster", (gogoproto.nullable) = false];

  // AuthInfos is a map of referencable names to user configs
  optional NamedAuthInfo user = 3 [(gogoproto.customname) = "AuthInfo", (gogoproto.nullable) = false];

  // Contexts is a map of referencable names to context configs
  optional NamedContext context = 4 [(gogoproto.customname) = "Context", (gogoproto.nullable) = false];
}

message LinodeSpec {
  // Linode
  optional string rootPassword = 1 [(gogoproto.customname) = "RootPassword", (gogoproto.nullable) = false];

  optional int64 kernelId = 2 [(gogoproto.customname) = "KernelId", (gogoproto.nullable) = false];
}

message LocalSpec {
  optional string path = 1 [(gogoproto.customname) = "Path", (gogoproto.nullable) = false];
}

message MachineProviderConfig {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  optional NodeSpec config = 2 [(gogoproto.customname) = "Config", (gogoproto.nullable) = false];
}

// NamedAuthInfo relates nicknames to auth information
message NamedAuthInfo {
  // Name is the nickname for this AuthInfo
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // ClientCertificateData contains PEM-encoded data from a client cert file for TLS.
  // +optional
  optional bytes clientCertificateData = 2 [(gogoproto.customname) = "ClientCertificateData"];

  // ClientKeyData contains PEM-encoded data from a client key file for TLS.
  // +optional
  optional bytes clientKeyData = 3 [(gogoproto.customname) = "ClientKeyData"];

  // Token is the bearer token for authentication to the kubernetes cluster.
  // +optional
  optional string token = 4 [(gogoproto.customname) = "Token", (gogoproto.nullable) = false];
}

// NamedCluster relates nicknames to cluster information
message NamedCluster {
  // Name is the nickname for this Cluster
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Server is the address of the kubernetes cluster (https://hostname:port).
  optional string server = 2 [(gogoproto.customname) = "Server", (gogoproto.nullable) = false];

  // CertificateAuthorityData contains PEM-encoded certificate authority certificates. Overrides CertificateAuthorityData
  // +optional
  optional bytes certificateAuthorityData = 3 [(gogoproto.customname) = "CertificateAuthorityData"];
}

// NamedContext relates nicknames to context information
message NamedContext {
  // Name is the nickname for this Context
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  // Cluster is the name of the cluster for this context
  optional string cluster = 2 [(gogoproto.customname) = "Cluster", (gogoproto.nullable) = false];

  // AuthInfo is the name of the authInfo for this context
  optional string user = 3 [(gogoproto.customname) = "AuthInfo", (gogoproto.nullable) = false];
}

message NodeInfo {
  optional string name = 1 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];

  optional string externalID = 2 [(gogoproto.customname) = "ExternalID", (gogoproto.nullable) = false];

  optional string publicIP = 3 [(gogoproto.customname) = "PublicIP", (gogoproto.nullable) = false];

  optional string privateIP = 4 [(gogoproto.customname) = "PrivateIP", (gogoproto.nullable) = false];

  optional string diskID = 5 [(gogoproto.customname) = "DiskId", (gogoproto.nullable) = false];
}

message NodeSpec {
  optional string sku = 1 [(gogoproto.customname) = "SKU", (gogoproto.nullable) = false];

  optional string nodeDiskType = 2 [(gogoproto.customname) = "DiskType", (gogoproto.nullable) = false];

  optional int64 nodeDiskSize = 3 [(gogoproto.customname) = "DiskSize", (gogoproto.nullable) = false];

  optional string externalIPType = 4 [(gogoproto.casttype) = "IPType", (gogoproto.customname) = "ExternalIPType", (gogoproto.nullable) = false];

  map<string, string> kubeletExtraArgs = 5 [(gogoproto.customname) = "KubeletExtraArgs", (gogoproto.nullable) = false];

  optional string type = 6 [(gogoproto.casttype) = "NodeType", (gogoproto.customname) = "Type", (gogoproto.nullable) = false];

  optional double spotPriceMax = 7 [(gogoproto.customname) = "SpotPriceMax", (gogoproto.nullable) = false];
}

message PharmerClusterSpec {
  // +optional
  optional Cluster clusterApi = 1 [(gogoproto.customname) = "ClusterAPI"];

  repeated Machine masters = 2 [(gogoproto.customname) = "Masters"];

  optional API api = 3 [(gogoproto.customname) = "API", (gogoproto.nullable) = false];

  optional string kubernetesVersion = 4 [(gogoproto.customname) = "KubernetesVersion", (gogoproto.nullable) = false];

  optional bool locked = 5 [(gogoproto.customname) = "Locked", (gogoproto.nullable) = false];

  optional string caCertName = 6 [(gogoproto.customname) = "CACertName", (gogoproto.nullable) = false];

  optional string frontProxyCACertName = 7 [(gogoproto.customname) = "FrontProxyCACertName", (gogoproto.nullable) = false];

  optional string credentialName = 8 [(gogoproto.customname) = "CredentialName", (gogoproto.nullable) = false];

  map<string, string> kubeletExtraArgs = 9 [(gogoproto.customname) = "KubeletExtraArgs", (gogoproto.nullable) = false];

  map<string, string> apiServerExtraArgs = 10 [(gogoproto.customname) = "APIServerExtraArgs", (gogoproto.nullable) = false];

  map<string, string> controllerManagerExtraArgs = 11 [(gogoproto.customname) = "ControllerManagerExtraArgs", (gogoproto.nullable) = false];

  map<string, string> schedulerExtraArgs = 12 [(gogoproto.customname) = "SchedulerExtraArgs", (gogoproto.nullable) = false];

  repeated string authorizationModes = 13 [(gogoproto.customname) = "AuthorizationModes"];

  repeated string apiServerCertSANs = 14 [(gogoproto.customname) = "APIServerCertSANs"];
}

message PharmerClusterStatus {
  optional string phase = 1 [(gogoproto.casttype) = "ClusterPhase", (gogoproto.customname) = "Phase", (gogoproto.nullable) = false];

  optional string reason = 2 [(gogoproto.customname) = "Reason", (gogoproto.nullable) = false];

  optional CloudStatus cloud = 4 [(gogoproto.customname) = "Cloud", (gogoproto.nullable) = false];

  repeated k8s.io.api.core.v1.NodeAddress apiServer = 5 [(gogoproto.customname) = "APIAddresses", (gogoproto.nullable) = false];

  repeated ReservedIP reservedIP = 6 [(gogoproto.customname) = "ReservedIPs", (gogoproto.nullable) = false];
}

message PharmerConfig {
  optional string context = 1 [(gogoproto.customname) = "Context", (gogoproto.nullable) = false];

  repeated Credential credentials = 2 [(gogoproto.customname) = "Credentials", (gogoproto.nullable) = false];

  optional StorageBackend store = 3 [(gogoproto.customname) = "Store", (gogoproto.nullable) = false];
}

message PostgresSpec {
  optional string dbName = 1 [(gogoproto.customname) = "DbName", (gogoproto.nullable) = false];

  optional string host = 2 [(gogoproto.customname) = "Host", (gogoproto.nullable) = false];

  optional int64 port = 3 [(gogoproto.customname) = "Port", (gogoproto.nullable) = false];

  optional string user = 4 [(gogoproto.customname) = "User", (gogoproto.nullable) = false];

  optional string password = 5 [(gogoproto.customname) = "Password", (gogoproto.nullable) = false];
}

message Preferences {
  // +optional
  optional bool colors = 1 [(gogoproto.customname) = "Colors", (gogoproto.nullable) = false];
}

message ReservedIP {
  optional string ip = 1 [(gogoproto.customname) = "IP", (gogoproto.nullable) = false];

  optional string id = 2 [(gogoproto.customname) = "ID", (gogoproto.nullable) = false];

  optional string name = 3 [(gogoproto.customname) = "Name", (gogoproto.nullable) = false];
}

message S3Spec {
  optional string endpoint = 1 [(gogoproto.customname) = "Endpoint", (gogoproto.nullable) = false];

  optional string bucket = 2 [(gogoproto.customname) = "Bucket", (gogoproto.nullable) = false];

  optional string prefix = 3 [(gogoproto.customname) = "Prefix", (gogoproto.nullable) = false];
}

message SSHConfig {
  optional bytes privateKey = 1 [(gogoproto.customname) = "PrivateKey"];

  optional string hostIP = 2 [(gogoproto.customname) = "HostIP", (gogoproto.nullable) = false];

  optional int32 hostPort = 3 [(gogoproto.customname) = "HostPort", (gogoproto.nullable) = false];

  optional string user = 4 [(gogoproto.customname) = "User", (gogoproto.nullable) = false];
}

message StorageBackend {
  optional string credentialName = 1 [(gogoproto.customname) = "CredentialName", (gogoproto.nullable) = false];

  optional LocalSpec local = 2 [(gogoproto.customname) = "Local"];

  optional S3Spec s3 = 3 [(gogoproto.customname) = "S3"];

  optional GCSSpec gcs = 4 [(gogoproto.customname) = "GCS"];

  optional AzureStorageSpec azure = 5 [(gogoproto.customname) = "Azure"];

  optional SwiftSpec swift = 6 [(gogoproto.customname) = "Swift"];

  optional PostgresSpec postgres = 7 [(gogoproto.customname) = "Postgres"];
}

message SwiftSpec {
  optional string container = 1 [(gogoproto.customname) = "Container", (gogoproto.nullable) = false];

  optional string prefix = 2 [(gogoproto.customname) = "Prefix", (gogoproto.nullable) = false];
}

